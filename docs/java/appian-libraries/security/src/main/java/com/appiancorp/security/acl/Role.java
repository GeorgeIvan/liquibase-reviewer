package com.appiancorp.security.acl;

import static com.google.common.collect.Iterables.transform;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;

import com.appian.core.persist.Constants;
import com.appiancorp.suiteapi.type.Hidden;
import com.appiancorp.suiteapi.type.Type;
import com.google.common.annotations.GwtCompatible;
import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

/**
 * A security role, like "Viewer" or "Editor".  Used in record-level security.
 */
@XmlRootElement(namespace=Type.APPIAN_NAMESPACE, name="role")
@XmlType(namespace=Type.APPIAN_NAMESPACE, name=Role.LOCAL_PART, propOrder={"id", "name"})
@Hidden
@Entity
@Table(name="rm_role")
@GwtCompatible
public class Role implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String LOCAL_PART = "Role";
  public static final QName QNAME = new QName(Type.APPIAN_NAMESPACE, Role.LOCAL_PART);

  private static final Function<String, Role> asRole = new Function<String, Role>() {
    @Override public Role apply(String roleName) {
      Role r = Roles.roleNameToRole.get(roleName);
      if (r != null) {
        return r;
      }
      throw new IllegalArgumentException("Role \"" + roleName + "\" not recognized.");
    }
  };

  private Long id;
  private String name;

  public Role(long id, String name) {
    this();
    setId(id);
    setName(name);
  }

  private Role() {} // for JAXB only

  @Id
  @XmlElement // required by JAXB because setter is private
  public Long getId() {
    return id;
  }
  private void setId(Long id) {
    this.id = Preconditions.checkNotNull(id);
  }

  @Column(length=Constants.COL_MAXLEN_INDEXABLE, nullable=false, unique=true)
  @XmlElement
  public String getName() {
    return name;
  }
  private void setName(String name) {
    this.name = Preconditions.checkNotNull(name);
  }

  public static final Function<Role, String> asRoleName = new Function<Role, String>() {
    @Override public String apply(Role s) {
      return s.getName();
    }
  };

  public static Role getRoleByName(String name) {
    return asRole.apply(name);
  }

  public static Set<Role> getRolesByNames(Set<String> roleNames) {
    Iterable<Role> roles = transform(roleNames, asRole);
    return Sets.newHashSet(roles);
  }

  @Override
  public String toString() {
    return "Role[id=" + id + ", name=" + name + "]";
  }

  // generated by Eclipse Indigo
  //
  // These objects get constructed as-needed and they also get loaded from the
  // RDBMS via queries, so I need value equality instead of reference equality.
  //
  // Ideally these would not be instantiable via normal
  // means, or just an enum, but they also have to be usable by Jaxb/hibernate.
  @Override
  public final int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
  }

  // generated by Eclipse Indigo
  @Override
  public final boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof Role)) {
      return false;
    }
    Role other = (Role) obj;
    if (id == null) {
      if (other.id != null) {
        return false;
      }
    } else if (!id.equals(other.id)) {
      return false;
    }
    if (name == null) {
      if (other.name != null) {
        return false;
      }
    } else if (!name.equals(other.name)) {
      return false;
    }
    return true;
  }

  public static Role calculateRole(Set<String> userRoleNames, ImmutableSet<Role> ascendingRoles) {
    Set<Role> userRoles = Role.getRolesByNames(userRoleNames);
    for (Role role : ascendingRoles) {
      if (userRoles.contains(role)) {
        return role;
      }
    }
    return null;
  }

  public static boolean hasSufficientPrivileges(String userRoleName, Role requiredRole,
      ImmutableSet<Role> ascendingRoles) {
    if (userRoleName == null) {
      return false;
    }
    Role userRole = Role.getRoleByName(userRoleName);
    List<Role> ascendingRolesList = new ArrayList<Role>(ascendingRoles);
    int idxOfUserRole = ascendingRolesList.indexOf(userRole);
    int idxOfRequiredRole = ascendingRolesList.indexOf(requiredRole);
    return idxOfUserRole >= 0 && idxOfUserRole <= idxOfRequiredRole;
  }
}
